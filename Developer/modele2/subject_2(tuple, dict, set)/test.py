'''

#Список - List

a = [1, 2, 3]
#создадим список из строк
a1=['a','b','c']
#список со вложенными спискам(двухмерный список)
a2=[[1, 2,],[3, 4]]
#если мы хотим вытащить тройку
#выбираем элемент из освного списка, затем тот элемент который нам нужен во вложенгом списке
a2=[1][0]

a.append(5)
print(5)

print(a.index(3))

a = [1,3,7,1]
a.sort()
#что бы сортировать по убыванию мы вользуемся реверс
a.sort(reverse=True)

#удалить с помощью ремув можно только конкретную цифру
a.remove(7)

print(a)


#Кортеж - Typle
"""
Кортежи во многом похожи на списки. 
Выбор в пользу кортежей стоит делать тогда, когда необходимо защитить данные 
от случайного изменения. Кроме того, многие операции с кортежами выполняются быстрее и занимают 
меньше памяти. В следующей статье будем изучать множества.
"""
#кортеж записывается в круглые скобки и кортеж не изменяется
#вот мы создали "а" и до конца программы у нас будет а 1,2,3
#вот у вса вчера был вопрос, а зачем он нам, ответ что он просто быстрее работает
a = (1,3,7,1)
давайте на примере посмотрим, возьмем из модуля сис, функцию получить размер
a = (1,3,7,1)
b = [1,3,7,1]

from sys import getsizeof as g
и давайте выведем сколько весит наш список
print(g(a))
print(g(b))


#1
from random import randint

numbers = [randint(-50, 50) for i in range(10)]
print(numbers)

#numbers = tuple(map(int, input().split()))
pos = tuple(i for i in numbers if i > 0)
neg = tuple(i for i in numbers if i < 0)
print(f'Кортеж {pos} состоит из {len(pos)} положительных чисел')
print(f'Кортеж {neg} состоит из {len(neg)} отрицательных чисел')

#Словари - Dict
"""
Словари и генераторы словарей помогают в решении задач, связанных 
с подсчетом, множественным выбором, хранением и обработкой значений, описывающих свойства объектов. 
Во многих случаях словари позволяют избежать использования 
многоуровневых условий if… elif… else. В следующей статье будем изучать методы кортежей.
"""
и тут разница больше чем со всеми остальными,
это переменные хранят множество значений и словарь это ассециативный список
то есть здесь нет индексов, здесь каждый элемент имеет свой ключ
каждый элемент выглядит вот так
key:value

d = {
	'key1':1,
	'key2':'idea',
	'key3':3,
}
то есть здесь мы обращаемся к ключам
print(d['key1'])

работать со словарями на самом деле нереально полезно, потому что на таком типе
мы можем быстренько наклепать там базу данных

items вывовдит все пары ключ-значение

print(d.items())
print(d.keys())
print(d.values())

#1
keys = input().split()
values = map(int, input().split())
my_dict = dict(zip(keys, values))
print(my_dict)

#Множества - Set
"""
Множества позволяют просто и лаконично решать задачи, связанные с уникальностью, вхождением 
элементов в определенные группы и совпадением (расхождением) в составе групп. 
Однако множества в Python имеют серьезный недостаток – они занимают значительный объем памяти, 
что может стать проблемой при решении олимпиадных задач. В следующей статье будем изучать цикл for.
"""

множество это тот же самый список, только он создается в фигурных скобках
разница заключается только в том что во множествах нет повторяющихся элементов
s = {1, 2, 3}
print(a)

s = {1, 2, 3, 2}
print(s)

единственное отличие что тут не append. а add
s.add(4)
print()

множество используется во всях математических задачях


#1
set_a, set_b, set_c = set(input("1 слово: ")), set(input("2 слово: " )), set(input("3 слово: "))
print('Да' if set_a == set_b == set_c else 'Нет')







множество это тот же самый список, только он создается в фигурных скобках
разница заключается только в том что во множествах нет повторяющихся элементов

# Множества - Set

#1
hobbies1 = input().split()
hobbies2 = input().split()
result = len(set(hobbies1) & set(hobbies2)) / float(len(set(hobbies1) | set(hobbies2))) * 100
print(f'Совпадение интересов: {result:.2f}%')


#2
result = {i.lower() for i in input() if i.isalpha()}
print('Да' if len(result) == 33 else 'Нет')

#3
n = int(input())
print('Количество уникальных символов во всех словах:', len(set(''.join([input().lower() for _ in range(n)]))))

#4
print(len(set(input().split(', ')) & set(input().split(', '))))

#5
print('Есть' if set(input()) & set(input()) else 'Нет')

#6
Метод str.endswith() возвращает True, если строка str заканчивается
указанным суффиксом suffix, в противном случае возвращает False.

files = input().split()
result = {i.lower() for i in files if i.lower().endswith('.jpg')}
print(*sorted(result))

#7
colors = [input().lower() for _ in range(int(input()))]
print('Повтор!' if len(colors) > len(set(colors)) else 'Принято')

#8
m, n = [int(input()) for _ in 'mn']
pantry = {input().lower() for _ in range(m)}
[print('Есть' if input().lower() in pantry else 'Отсутствует') for _ in range(n)]


#Кортеж - Typle

#1
my_tuple = tuple(map(float, input().split()))
print(f'Минимальное число: {min(my_tuple)}')
print(f'Максимальное число: {max(my_tuple)}')
print(f'Сумма min и max: {((min(my_tuple) + max(my_tuple))):.2f}')

#2
fruit = (['яблоки', 46], ['персики', 49], ['лимоны', 36], ['виноград', 190])
fruit[3][1] = 75
fruit[2].extend(['айва', 42])
print(fruit)

#3
numbers = ((5, 4, 5, 4), (3, 3, 4, 6), (8, 9, 5, 4), (12, 4, 5, 1), (9, 3, 5, 1))
avg = tuple(sum(i)/len(i) for i in numbers)
print(*avg)

#4
nested_tuple = ((12, 3, 1), (5, 11), (15, 7, 8, 9), (10, 6, 4))
res = []
flat_list = [res.extend(i) for i in nested_tuple]
print(tuple(sorted(res)))


"""
Ключевое слово lambda названо в честь лямбда абстракции — основного кирпичика Лямбда И
счисления, математического аппарата, часто применяющегося в разработке языков программирования. 
В Лямбда Исчислении все функции — анонимные, поэтому анонимные функции во многих 
языках тоже иногда называют "лямбдами" или "лямбда-функциями".

Пример, использующий анонимную функцию:
l = [1, 2, 5, 3, 4] 
l.sort(key=lambda x: -x) 
l # [5, 4, 3, 2, 1]


Метод sort принимает в качестве аргумента key ссылку на функцию. 
В примере в качестве аргумента указана функция, меняющая знак у а
ргумента — поэтому список получается отсортирован от большего к меньшему. 
Сортировка с указанием ключа сама по себе встречается довольно часто, а вот ключи сортировки чаще 
всего будут разными. Поэтому выносить ключи в именованные функции смысла нет и анонимные функции 
здесь подходят идеально!
"""
nested_tuple = (('красный', 33, 55), ('зеленый', 17, 44), ('синий', 12, 3), ('черный', 2, 5))
nested_tuple = tuple(sorted(list(nested_tuple), key=lambda x: x[2]))
print(nested_tuple)

#5
my_tuple = tuple(input().split())
print(all(i == my_tuple[0] for i in my_tuple))

#6
info = (('Евгений Романов', 25, '+56(983)354-67-21'),
    	('Марина Дятлова', 22, '+56(190)251-45-79'),
    	('Кирилл Кудрявцев', 34, '+7(890)456-12-42'),
    	('Сергей Дятлов', 24, '+56(190)156-42-99'),
    	('Юлия Степанова', 21, '+16(398)355-33-09'),
    	('Тимофей Иванов', 34, '+7(918)222-52-77'))
new_info = tuple([i for i in info if not i[2].startswith('+56')])
print(new_info)

#7
numbers = ([4, 5], [4, 5], [1, 6], [7, 3], [3, 3], [2, 4], [9, 5], [1, 1])
add = [i.extend([5]) for i in numbers]
print(numbers)

#8
n = int(input())
points = [tuple(map(int, input().split())) for i in range(n)]
mx = max(points, key=lambda x: x[0] ** 2 + x[1] ** 2)
print(*mx)

#Словари - Dict
"""
Словари и генераторы словарей помогают в решении задач, связанных 
с подсчетом, множественным выбором, хранением и обработкой значений, описывающих свойства объектов. 
Во многих случаях словари позволяют избежать использования 
многоуровневых условий if… elif… else. В следующей статье будем изучать методы кортежей.

и тут разница больше чем со всеми остальными,
это переменные хранят множество значений и словарь это ассециативный список
то есть здесь нет индексов, здесь каждый элемент имеет свой ключ
каждый элемент выглядит вот так
key:value
"""

#1
keys = input().split()
values = map(int, input().split())
my_dict = dict(zip(keys, values))
print(my_dict)

#2
nums = map(int, input().split())
my_dict = {n: 'четное' for n in nums if n % 2 == 0}
print(my_dict)

#3
st = input().lower()
my_dict = {i: st.count(i) for i in st}
print(*[str(k) + '-' + str(v) for k, v in my_dict.items()])

#4
word1, word2 = input().lower(), input().lower()
c = {k: word1.count(k) for k in word1}
d = {k: word2.count(k) for k in word2}
print ('Да' if c == d else 'Нет')

#5
sp = [[i.split(', ')[0], i.split(',')[1]] for i in input().split('; ')]
my_dict = {k: v for v, k in sp}
result = '\n'.join(f'{k}: {v}' for k, v in my_dict.items())
print(result)

#6,
st = input().split('; ')
phones = {i.split()[0]:i.split()[1] for i in st}
name = input()
print(phones.get(name, 'Нет такого абонента'))

#7
sp1 = input().split()
sp2 = map(int, input().split())
my_dict = dict(zip(sp1, sp2))
print('Есть' if 5 in my_dict.values() else 'Нет')

#8
months = {1: 'Январь', 2: 'Февраль', 3: 'Март', 4: 'Апрель',
       	5: 'Май', 6: 'Июнь', 7: 'Июль', 8: 'Август',
      	9: 'Сентябрь', 10: 'Октябрь', 11: 'Ноябрь', 12: 'Декабрь'}
num = int(input())
print(months.get(num, 'Введите число от 1 до 12'))

#9
my_dict = {k:v for _ in range(3) for k, *v in  [input().split()]}
city = input()
[print(k) for k, v in my_dict.items() if city in v]

#10
numbers = {key: [i for i in value if i % 2 != 0] for key, value in numbers.items()}
print(numbers)
'''


